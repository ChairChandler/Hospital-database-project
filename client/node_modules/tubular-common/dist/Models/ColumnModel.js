"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Column_1 = require("./Column");
function filterProps(name) {
    return {
        argument: [],
        hasFilter: false,
        name: name,
        operator: 'None',
        text: null,
    };
}
var NumericOperators = [
    { value: Column_1.CompareOperators.None, title: 'None' },
    { value: Column_1.CompareOperators.Equals, title: 'Equals' },
    { value: Column_1.CompareOperators.Between, title: 'Between' },
    { value: Column_1.CompareOperators.Gte, title: '>=' },
    { value: Column_1.CompareOperators.Gt, title: '>' },
    { value: Column_1.CompareOperators.Lte, title: '<=' },
    { value: Column_1.CompareOperators.Lt, title: '<' },
];
var StringOperators = [
    { value: Column_1.CompareOperators.None, title: 'None' },
    { value: Column_1.CompareOperators.Equals, title: 'Equals' },
    { value: Column_1.CompareOperators.NotEquals, title: 'Not Equals' },
    { value: Column_1.CompareOperators.Contains, title: 'Contains' },
    { value: Column_1.CompareOperators.NotContains, title: 'Not Contains' },
    { value: Column_1.CompareOperators.StartsWith, title: 'Starts With' },
    { value: Column_1.CompareOperators.NotStartsWith, title: 'Not Starts With' },
    { value: Column_1.CompareOperators.EndsWith, title: 'Ends With' },
    { value: Column_1.CompareOperators.NotEndsWith, title: 'Not Ends With' },
];
var BooleanOperators = [
    { value: Column_1.CompareOperators.None, title: 'None' },
    { value: Column_1.CompareOperators.Equals, title: 'Equals' },
    { value: Column_1.CompareOperators.NotEquals, title: 'Not Equals' },
];
var ColumnModel = /** @class */ (function () {
    function ColumnModel(name, options) {
        this.hasFilter = this.filter && (this.filter.text || this.filter.argument) && this.filter.operator !== Column_1.CompareOperators.None;
        this.aggregate = (options && options.aggregate) || Column_1.AggregateFunctions.None;
        this.dataType = (options && options.dataType) || Column_1.ColumnDataType.String;
        this.isKey = (options && options.isKey) || false;
        this.label = (options && options.label) || (name || '').replace(/([a-z])([A-Z])/g, '$1 $2');
        this.name = name;
        this.searchable = (options && options.searchable) || false;
        this.sortDirection = (options && options.sortable && options.sortDirection) || Column_1.ColumnSortDirection.None;
        this.sortOrder = (options && this.sortDirection !== Column_1.ColumnSortDirection.None && options.sortOrder) || -1;
        this.sortable = (options && options.sortable) || false;
        this.visible = options && typeof options.visible === 'boolean' ? options.visible : true;
        this.filter =
            options && options.filterable === true
                ? filterProps(name)
                : { argument: [], operator: Column_1.CompareOperators.None, hasFilter: false };
        this.filterable = (options && options.filterable) || false;
        this.filter.hasFilter = this.hasFilter;
    }
    ColumnModel.createFilterPatch = function (column) {
        var filterText = column.filter.text;
        var filterArgument = column.filter.argument[0];
        if (column.dataType === Column_1.ColumnDataType.Numeric) {
            filterText = parseFloat(filterText).toString();
            filterArgument = parseFloat(filterArgument).toString();
        }
        else if (column.dataType === Column_1.ColumnDataType.Boolean) {
            filterText = (filterText === 'true').toString();
            filterArgument = '';
        }
        return {
            name: column.name,
            argument: [filterArgument],
            hasFilter: true,
            operator: column.filter.operator || Column_1.CompareOperators.Auto,
            text: filterText,
        };
    };
    ColumnModel.getOperators = function (column) {
        switch (column.dataType) {
            case Column_1.ColumnDataType.String:
                return StringOperators;
            case Column_1.ColumnDataType.Numeric:
            case Column_1.ColumnDataType.Date:
            case Column_1.ColumnDataType.DateTime:
            case Column_1.ColumnDataType.DateTimeUtc:
                return NumericOperators;
            case Column_1.ColumnDataType.Boolean:
                return BooleanOperators;
            default:
                return [];
        }
    };
    ColumnModel.sortColumnArray = function (columnName, columns, multiSort) {
        var column = columns.find(function (c) { return c.name === columnName; });
        if (!column) {
            return;
        }
        column.sortDirection =
            column.sortDirection === Column_1.ColumnSortDirection.None
                ? Column_1.ColumnSortDirection.Ascending
                : column.sortDirection === Column_1.ColumnSortDirection.Ascending
                    ? Column_1.ColumnSortDirection.Descending
                    : Column_1.ColumnSortDirection.None;
        column.sortOrder = column.sortDirection === Column_1.ColumnSortDirection.None ? -1 : Number.MAX_VALUE;
        if (!multiSort) {
            columns
                .filter(function (col) { return col.name !== columnName; })
                .forEach(function (c) {
                c.sortOrder = -1;
                c.sortDirection = Column_1.ColumnSortDirection.None;
            });
        }
        columns
            .filter(function (col) { return col.sortOrder > 0; })
            .sort(function (a, b) {
            return a.sortOrder === b.sortOrder ? 0 : a.sortOrder > b.sortOrder ? 1 : -1;
        })
            .forEach(function (col, i) {
            col.sortOrder = i + 1;
        });
        return columns;
    };
    ColumnModel.clearFilterPatch = function () {
        return {
            argument: [''],
            hasFilter: false,
            operator: Column_1.CompareOperators.None,
            text: '',
        };
    };
    return ColumnModel;
}());
exports.default = ColumnModel;
