"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var uno_js_1 = require("uno-js");
var Models_1 = require("./Models");
var GridResponse_1 = require("./Models/GridResponse");
var utils_1 = require("./utils");
var isEqual = function (date1, date2) { return uno_js_1.parseISO(date1).getTime() === uno_js_1.parseISO(date2).getTime(); };
var isAfter = function (date1, date2) { return uno_js_1.parseISO(date1).getTime() > uno_js_1.parseISO(date2).getTime(); };
var isBefore = function (date1, date2) { return uno_js_1.parseISO(date1).getTime() < uno_js_1.parseISO(date2).getTime(); };
var Transformer = /** @class */ (function () {
    function Transformer() {
    }
    Transformer.getResponse = function (request, dataSource) {
        var response = new GridResponse_1.default(request.counter);
        response.totalRecordCount = dataSource.length;
        var data = this.applyFreeTextSearch(request, dataSource);
        data = this.applyFiltering(request, data);
        data = this.applySorting(request, data);
        response.filteredRecordCount = data.length;
        if (request.take > -1) {
            response.totalPages = Math.ceil(response.filteredRecordCount / request.take);
            if (response.totalPages > 0) {
                response.currentPage = request.skip / request.take + 1;
            }
        }
        response.aggregationPayload = this.getAggregatePayload(request, data);
        response.payload = data
            .slice(request.skip, request.skip + request.take)
            .map(function (row) { return utils_1.parsePayload(row, request.columns); });
        return response;
    };
    Transformer.applyFreeTextSearch = function (request, subset) {
        if (request.search && request.search.operator.toLowerCase() === Models_1.CompareOperators.Auto.toLowerCase()) {
            var searchableColumns_1 = request.columns.filter(function (x) { return x.searchable; });
            if (searchableColumns_1.length > 0) {
                var filter_1 = request.search.text.toLowerCase();
                if (filter_1 === '') {
                    return subset;
                }
                return subset.filter(function (item) {
                    return searchableColumns_1.some(function (x) {
                        if (typeof item[x.name] === 'undefined') {
                            return false;
                        }
                        else {
                            return item[x.name].toLowerCase().indexOf(filter_1) > -1;
                        }
                    });
                });
            }
            return subset;
        }
    };
    Transformer.applyFiltering = function (request, subset) {
        request.columns
            .filter(function (column) { return column.hasFilter; })
            .forEach(function (column) {
            var isDate = column.dataType === Models_1.ColumnDataType.Date ||
                column.dataType === Models_1.ColumnDataType.DateTime ||
                column.dataType === Models_1.ColumnDataType.DateTimeUtc;
            var partialfiltering = function (data, action) {
                return data.filter(function (row) {
                    return typeof row[column.name] === 'undefined' || row[column.name] === null
                        ? false
                        : action(row[column.name]);
                });
            };
            switch (column.filter.operator) {
                case Models_1.CompareOperators.Equals:
                    if (isDate) {
                        subset = subset.filter(function (row) { return isEqual(row[column.name], column.filter.text); });
                    }
                    else if (column.dataType === Models_1.ColumnDataType.String) {
                        subset = partialfiltering(subset, function (x) { return x.toLowerCase() === column.filter.text.toLowerCase(); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] === column.filter.text; });
                    }
                    break;
                case Models_1.CompareOperators.NotEquals:
                    if (column.dataType === 'string') {
                        subset = partialfiltering(subset, function (x) { return x.toLowerCase() !== column.filter.text.toLowerCase(); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] !== column.filter.text; });
                    }
                    break;
                case Models_1.CompareOperators.Contains:
                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.filter.text.toLowerCase()) >= 0; });
                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.filter.text.toLowerCase()) >= 0; });
                    break;
                case Models_1.CompareOperators.NotContains:
                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.filter.text.toLowerCase()) < 0; });
                    break;
                case Models_1.CompareOperators.StartsWith:
                    subset = partialfiltering(subset, function (x) {
                        return x.toLowerCase().startsWith(column.filter.text.toLowerCase());
                    });
                    break;
                case Models_1.CompareOperators.NotStartsWith:
                    subset = partialfiltering(subset, function (x) { return !x.toLowerCase().startsWith(column.filter.text.toLowerCase()); });
                    break;
                case Models_1.CompareOperators.EndsWith:
                    subset = partialfiltering(subset, function (x) {
                        return x.toLowerCase().endsWith(column.filter.text.toLowerCase());
                    });
                case Models_1.CompareOperators.NotEndsWith:
                    subset = partialfiltering(subset, function (x) { return !x.toLowerCase().endsWith(column.filter.text.toLowerCase()); });
                    break;
                case Models_1.CompareOperators.Gt:
                    if (isDate) {
                        subset = subset.filter(function (row) { return isAfter(row[column.name], column.filter.text); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] > column.filter.text; });
                    }
                    break;
                case Models_1.CompareOperators.Gte:
                    if (isDate) {
                        subset = subset.filter(function (row) {
                            return isEqual(row[column.name], column.filter.text) ||
                                isAfter(row[column.name], column.filter.text);
                        });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] >= column.filter.text; });
                    }
                    break;
                case Models_1.CompareOperators.Lt:
                    if (isDate) {
                        subset = subset.filter(function (row) { return isBefore(row[column.name], column.filter.text); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] < column.filter.text; });
                    }
                    break;
                case Models_1.CompareOperators.Lte:
                    if (isDate) {
                        subset = subset.filter(function (row) {
                            return isEqual(row[column.name], column.filter.text) ||
                                isBefore(row[column.name], column.filter.text);
                        });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] <= column.filter.text; });
                    }
                    break;
                case Models_1.CompareOperators.Between:
                    if (isDate) {
                        subset = subset.filter(function (row) {
                            return (isEqual(row[column.name], column.filter.text) ||
                                isAfter(row[column.name], column.filter.text)) &&
                                (isEqual(row[column.name], column.filter.argument[0]) ||
                                    isBefore(row[column.name], column.filter.argument[0]));
                        });
                    }
                    else {
                        subset = subset.filter(function (row) {
                            return row[column.name] >= column.filter.text &&
                                row[column.name] <= column.filter.argument[0];
                        });
                    }
                    break;
                default:
                    throw new Error('Unsupported Compare Operator');
            }
        });
        return subset;
    };
    Transformer.applySorting = function (request, subset) {
        var sortedColumns = request.columns.filter(function (column) { return column.sortOrder > 0; });
        var sorts = [{ name: request.columns[0].name, asc: true }];
        if (sortedColumns.length > 0) {
            sortedColumns.sort(function (a, b) { return (a.sortOrder > b.sortOrder ? 1 : b.sortOrder > a.sortOrder ? -1 : 0); });
            sorts = sortedColumns.map(function (y) { return ({
                name: y.name,
                asc: y.sortDirection === Models_1.ColumnSortDirection.Ascending,
            }); });
        }
        subset.sort(function (a, b) {
            var result = 0;
            for (var _i = 0, sorts_1 = sorts; _i < sorts_1.length; _i++) {
                var current = sorts_1[_i];
                var reverse = current.asc ? 1 : -1;
                if (typeof a[current.name] === 'undefined' || typeof b[current.name] === 'undefined') {
                    result = reverse * -1;
                    break;
                }
                if (a[current.name] < b[current.name]) {
                    result = reverse * -1;
                    break;
                }
                if (a[current.name] > b[current.name]) {
                    result = reverse * 1;
                    break;
                }
            }
            return result;
        });
        return subset;
    };
    Transformer.getAggregatePayload = function (request, subset) {
        var aggregateColumns = request.columns.filter(function (column) {
            return column.aggregate && column.aggregate.toLowerCase() !== Models_1.AggregateFunctions.None.toLowerCase();
        });
        return aggregateColumns.reduce(function (prev, column) {
            switch (column.aggregate.toLowerCase()) {
                case Models_1.AggregateFunctions.Sum.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (sum, r) { return (typeof r[column.name] === 'undefined' ? sum : sum + r[column.name]); }, 0);
                    break;
                case Models_1.AggregateFunctions.Average.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (sum, r) { return (typeof r[column.name] === 'undefined' ? sum : sum + r[column.name]); }, 0) / subset.length;
                    break;
                case Models_1.AggregateFunctions.Max.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (max, r) { return (r[column.name] > max ? r[column.name] : max); }, subset[0][column.name]);
                    break;
                case Models_1.AggregateFunctions.Min.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (min, r) { return (r[column.name] < min ? r[column.name] : min); }, subset[0][column.name]);
                    break;
                case Models_1.AggregateFunctions.Count.toLowerCase():
                    prev[column.name] = subset.length;
                    break;
                case Models_1.AggregateFunctions.DistinctCount.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (list, r) {
                                if (list.indexOf(r[column.name]) === -1) {
                                    list.push(r[column.name]);
                                }
                                return list;
                            }, []).length;
                    break;
                default:
                    throw new Error('Unsupported aggregate function');
            }
            return prev;
        }, {});
    };
    return Transformer;
}());
exports.default = Transformer;
